public final class Calendar<T> implements ListInterface<T>
{

    @Override
    public void add( int newPosition, T newEntry )
    {
    	//we should change the input newPosition to something that can be sorted like date
        Node current = this.getNodeAtPosition( newPosition );

        // pointing at the first node in the list if null or if newPosition=1
        Node prev = this.getNodeAtPosition(newPosition -1);
        if (current.data != null)
        {

        }
        else
        {

        }
    }

    @Override
    public void add( T newEntry )
    {
        Node n = new Node( newEntry );

        if (this.head == null)
        {
            this.head = n;
        }
        else
        {
            n.next = this.head;
            this.head = n;
        }
        this.countOfEntries++;

    }

    @Override
    public void clear( )
    {
        this.head = null;
    }

    @Override
    public boolean contains( T anEntry )
    {
        boolean result =false;
        Node current = this.head;
        //int posCounter = 1;
        while( ( current!=null ) && anEntry.equals( current.data )
                )
        { if( result = true)
        current = this.head.next;
        }
        return result;
    }

    @Override
    public T getEntry( int givenPosition )
    {
        T data = null;
        Node n = this.getNodeAtPosition( givenPosition );
        data = n.getData( );
        return data;
    }

    @Override
    public int getLength( )
    {
        return 0;
    }

    @Override
    public boolean isEmpty( )
    {
        return false;
    }

    @Override
    public T remove( int givenPosition )
    {
        return null;
    }

    @Override
    public T replace( int givenPosition, T newEntry )
    {
        return null;
    }

    @Override
    public T[ ] toArray( )
    {
        return null;
    }

    @Override
    public String toString( )
    {
        return "Calendar [head=" + this.head + ", tail=" + this.tail + "]";
    }

    private Node getNodeAtPosition( int position )
    {
        Node current = this.head;
        int posCounter = 1;
        while (( current != null ) && ( posCounter < position ))
        {
            current = current.next;
            posCounter++;
        }
        return current;
    }

    private int countOfEntries = 0;

    Node<T>     head           = null;

    Node<T>     tail           = null;

}
